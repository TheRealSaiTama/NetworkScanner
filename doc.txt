Project Goal:

Develop a comprehensive network scanner application capable of discovering devices, identifying their MAC addresses, and detecting open ports within a specified IP range. The tool should leverage the Scapy library (or similar) for packet crafting and manipulation, providing both a command-line interface and a graphical user interface (GUI) for displaying and interacting with scan results. The scanner should be efficient and scalable, capable of handling both small and large networks.

1. Environment Setup

This section details the necessary prerequisites and initial configuration steps for the project.

1.1. Installing Python 3.8 or Higher:

Description: The project requires a Python installation of version 3.8 or higher. This ensures compatibility with the latest features and libraries used in the project.

Steps:

Download: Obtain the appropriate Python installer from the official Python website (https://www.python.org/downloads/).

Installation: Run the installer, ensuring that the "Add Python to PATH" option is selected during the installation process. This allows you to run Python commands from any directory in your terminal.

Verification: Open a terminal or command prompt and run python --version or python3 --version to confirm the installed version.

1.2. Installing Scapy Library:

Description: Scapy is a powerful Python library for packet manipulation and network discovery. It's the core library for this project.

Steps:

Using pip: Open a terminal and use the Python package installer (pip) to install Scapy:

pip install scapy


If you encounter issues, you might need to use pip3 instead of pip, depending on your Python environment setup.

Verification:

import scapy.all as scapy
print(scapy.conf)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

1.3. Installing the IP Address Library:

Description: This library handles IP address and network range calculations. Python's built-in ipaddress module is sufficient.

Steps: No separate installation is needed; the ipaddress module is part of the Python standard library.

import ipaddress

# Example usage
network = ipaddress.ip_network('192.168.1.0/24')
print(f"Network address: {network.network_address}")
for ip in network.hosts():
    print(ip)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

1.4. Setting Up Data Visualization Libraries:

Description: These libraries are used for creating graphical representations of the network topology and scan results (in the GUI). Examples include matplotlib, plotly, or networkx (for network graph visualization).

Steps:

Installation: Install the chosen libraries using pip:

pip install matplotlib  # For basic plotting
pip install plotly    # For interactive plots
pip install networkx  # For network graph visualizations
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END

Example (matplotlib):

import matplotlib.pyplot as plt
 ports = [22, 80, 443]
 open_status = [True, True, False]
 plt.bar(ports, open_status)
 plt.xlabel("Port")
 plt.ylabel("Open")
 plt.show()
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

1.5. Configuring Permissions for Raw Socket Access:

Description: Scapy requires raw socket access to send and receive packets at a low level. This often requires elevated privileges (administrator/root).

Steps (Linux/macOS):

Run as Root: You can run your script with sudo:

sudo python your_script.py
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END

Setuid (Less Recommended): You could set the setuid bit on the Python executable, but this is generally discouraged due to security implications.

Capabilities (Best Approach - Linux): Use Linux capabilities to grant the Python interpreter the CAP_NET_RAW capability, allowing it to open raw sockets without full root privileges.

sudo setcap cap_net_raw+ep /usr/bin/python3.x  # Replace 3.x with your Python version
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END

Steps (Windows):

Run as Administrator: Run your command prompt or PowerShell window as an administrator. Right-click the icon and choose "Run as administrator."

Npcap/WinPcap: Ensure that Npcap (recommended) or WinPcap is installed. Scapy relies on these packet capture libraries on Windows. The Scapy installation process usually handles this, but you may need to install it manually from https://npcap.com/.

1.6. Setting Up Project Directory Structure:

Description: A well-organized directory structure helps manage the codebase and related files.

Proposed Structure:

network_scanner_pro/
├── src/                 # Source code directory
│   ├── scanner.py       # Main scanning logic
│   ├── utils.py         # Utility functions (e.g., IP parsing, result formatting)
│   ├── cli.py           # Command-line interface implementation
│   ├── gui.py           # GUI implementation (if applicable)
│   └── ...             # Other modules as needed
├── results/             # Directory to store scan results (optional)
├── requirements.txt     # List of project dependencies (for pip)
├── README.md            # Project description and instructions
└── ...
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

1.7. Setting Up Environment for Large Network Scanning:

Description: Considerations for handling large network scans, potentially involving thousands of hosts and ports.

Strategies:

Concurrency: Utilize Python's threading or asyncio modules for parallel scanning. This is crucial for performance.

Timeouts: Implement appropriate timeouts to prevent the scanner from hanging indefinitely on unresponsive hosts or ports.

Rate Limiting: Consider adding rate limiting to avoid overwhelming the network or triggering intrusion detection systems.

Resource Management: Be mindful of memory usage, especially when storing scan results. Consider using generators or iterators to process data in chunks rather than loading everything into memory at once.

2. ARP/ICMP Scanning

This section covers the implementation of Address Resolution Protocol (ARP) and Internet Control Message Protocol (ICMP) scanning to discover active hosts on the network.

2.1. ARP Request and Response Handling Function:

Description: Create a function to send ARP requests and process the responses. This is used to determine which IP addresses have corresponding MAC addresses (i.e., which hosts are alive).

Implementation (Scapy):

import scapy.all as scapy
import ipaddress

def arp_scan(ip_range):
    """Performs an ARP scan on the given IP range.

    Args:
        ip_range: The IP range to scan (e.g., "192.168.1.0/24").

    Returns:
        A list of dictionaries, each containing "ip" and "mac" keys for discovered hosts.
    """
    arp_request = scapy.ARP(pdst=ip_range)
    broadcast = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")  # Broadcast MAC address
    arp_request_broadcast = broadcast / arp_request
    answered_list = scapy.srp(arp_request_broadcast, timeout=2, verbose=False)[0]

    clients_list = []
    for element in answered_list:
        client_dict = {"ip": element[1].psrc, "mac": element[1].hwsrc}
        clients_list.append(client_dict)
    return clients_list

# Example usage:
# results = arp_scan("192.168.1.0/24")
# for client in results:
#    print(f"IP: {client['ip']}, MAC: {client['mac']}")
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

2.2. Parsing ARP Response Packets with Python and Scapy: The arp_scan function above already handles this. Scapy's srp() function returns a list of answered and unanswered packets. We extract the IP and MAC addresses from the psrc and hwsrc fields of the answered packets.

2.3. Implementing ICMP Echo Request for Network Scanner:

Description: Create a function to send ICMP Echo Requests (ping) to discover hosts. This is an alternative to ARP, especially useful for hosts that might block ARP requests.

Implementation (Scapy):

import scapy.all as scapy

def ping_scan(ip_address):
    """Sends an ICMP Echo Request to the given IP address.

    Args:
        ip_address: The IP address to ping.

    Returns:
        True if the host is reachable, False otherwise.
    """
    icmp_request = scapy.IP(dst=ip_address) / scapy.ICMP()
    response = scapy.sr1(icmp_request, timeout=2, verbose=False)
    return response is not None
#Example
# if ping_scan("192.168.1.1"):
#     print("192.168.1.1 is reachable")
# else:
#     print("192.168.1.1 is not reachable")
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

2.4. Detecting Active Devices with ICMP: The ping_scan function above already handles this. A successful ICMP Echo Reply indicates an active device.

2.5. Detecting Non-Responding Devices in Network Scanning: Both the ARP and ICMP scan functions can detect non-responding devices. In the ARP scan, hosts that don't send a reply are considered non-responding. In the ICMP scan, a None response indicates a non-responding host.

2.6. Optimizing Network Scanner for Large Networks: See section 1.7 for general optimization strategies (concurrency, timeouts, rate limiting). For ARP/ICMP specifically:

ARP Sweep: Instead of sending individual ARP requests for each IP, use an ARP sweep (which is what the arp_scan function already does).

ICMP Sweep: Similarly, send ICMP requests in batches rather than one at a time. The sr() function in Scapy can handle this.

2.7. Implementing Parallel Processing in Network Scanner:

Description: Use Python's threading or concurrent.futures module to perform scans in parallel, significantly speeding up the process.

Example (using concurrent.futures):

import concurrent.futures
import scapy.all as scapy
import ipaddress

def scan_host(ip):  # Combined ARP and ICMP for this example
    arp_result = arp_scan(str(ip))  # Use our previous arp_scan function
    if arp_result:
        return {"ip": str(ip), "mac": arp_result[0]['mac'], "status": "up"}
    elif ping_scan(str(ip)):  # Use our previous ping_scan function
        return {"ip": str(ip), "mac": None, "status": "up (ICMP)"}
    else:
        return {"ip": str(ip), "mac": None, "status": "down"}
def parallel_scan(ip_range, max_workers=10): #max_workers defines the number of threads.
   """Performs a parallel scan of the given IP range."""
   with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
        future_to_ip = {executor.submit(scan_host, ip): ip for ip in ipaddress.ip_network(ip_range).hosts()}
        results = []
        for future in concurrent.futures.as_completed(future_to_ip):
            result = future.result()
            results.append(result)
        return results

# Example Usage
# scan_results = parallel_scan("192.168.1.0/24")
# for result in scan_results:
#     print(result)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

This example combines both ARP and ICMP scanning into a single scan_host function for simplicity, and uses concurrent.futures.ThreadPoolExecutor to run the scans concurrently. Adjust max_workers based on your system resources and network conditions.

3. TCP Port Scanning

This section details how to implement TCP port scanning to identify open ports on discovered hosts.

3.1. TCP SYN Packet Sender Implementation:

Description: Create a function to send TCP SYN packets to a target host and port. This is the first step in a TCP three-way handshake.

Implementation (Scapy):

import scapy.all as scapy

def send_syn(ip_address, port):
    """Sends a TCP SYN packet to the specified IP address and port.

    Args:
        ip_address: The target IP address.
        port: The target port.

    Returns:
        The response packet if received, None otherwise.
    """
    ip = scapy.IP(dst=ip_address)
    tcp = scapy.TCP(dport=port, flags="S")  # "S" flag for SYN
    packet = ip / tcp
    response = scapy.sr1(packet, timeout=1, verbose=False)
    return response
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

3.2. Handling TCP SYN-ACK Responses for Port Scanning:

Description: Process the response from the target host. A SYN-ACK response indicates an open port.

Implementation (expanding the previous function):

def is_port_open(ip_address, port):
    """Checks if a port is open using a TCP SYN scan.

    Args:
        ip_address: The target IP address.
        port: The target port.

    Returns:
        True if the port is open, False otherwise.
    """
    response = send_syn(ip_address, port)
    if response and response.haslayer(scapy.TCP):
        if response[scapy.TCP].flags == "SA":  # SYN-ACK flags
            # Send a RST packet to close the connection politely
            rst_packet = scapy.IP(dst=ip_address) / scapy.TCP(dport=port, sport=response[scapy.TCP].dport, seq=response[scapy.TCP].ack, ack=response[scapy.TCP].seq + 1, flags="R")
            scapy.send(rst_packet, verbose=False)
            return True
    return False

# Example Usage:
# if is_port_open("192.168.1.1", 80):
#     print("Port 80 is open")
# else:
#    print("Port 80 is closed/filtered")
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

3.3. Implement Connection Timeout and Retry in TCP Port Scanner: The scapy.sr1() function already has a timeout parameter, which handles connection timeouts. For retries, you can wrap the port scanning logic in a loop:

def is_port_open_with_retry(ip_address, port, retries=3):
    for _ in range(retries):
       if is_port_open(ip_address, port):
          return True
    return False
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

3.4. Adding User-Defined Port Ranges to Network Scanner:

Description: Allow the user to specify a range of ports to scan (e.g., 1-1024, 80, 443, 8000-8080).

Implementation:

def scan_ports(ip_address, port_ranges):
   """Scans a range of ports on a target IP address.

   Args:
       ip_address: The target IP address.
       port_ranges: A string defining port ranges (e.g., "1-1024, 80, 443").

   Returns:
       A list of open ports.
   """
   open_ports = []
   for port_range in port_ranges.split(","):
       port_range = port_range.strip()
       if "-" in port_range:
           start_port, end_port = map(int, port_range.split("-"))
           for port in range(start_port, end_port + 1):
              if is_port_open(ip_address, port):
                open_ports.append(port)
       else:
           port = int(port_range)
           if is_port_open(ip_address, port):
               open_ports.append(port)
   return open_ports
#Example Usage:
# open_ports = scan_ports("192.168.1.1", "22, 80, 443, 1000-1024")
# print(f"Open ports: {open_ports}")
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

3.5. Implementing ACK Scan in Network Scanner:

Description: Perform an ACK scan. This type of scan is used to determine if a firewall is stateful or stateless.

Implementation (Scapy):

def ack_scan(ip_address, port):
    """Performs a TCP ACK scan on the specified IP address and port.

    Args:
        ip_address: The target IP address.
        port: The target port.

    Returns:
        "unfiltered" if the port is unfiltered (RST response),
        "filtered" if the port is filtered (no response or ICMP error),
        None on error.
    """
    ip = scapy.IP(dst=ip_address)
    tcp = scapy.TCP(dport=port, flags="A")  # "A" flag for ACK
    packet = ip / tcp
    response = scapy.sr1(packet, timeout=1, verbose=False)

    if response is None:
        return "filtered"
    elif response.haslayer(scapy.TCP):
        if response[scapy.TCP].flags == "R":  # RST flag
            return "unfiltered"
    elif response.haslayer(scapy.ICMP):
        # Check for ICMP error types indicating filtering
        if response[scapy.ICMP].type == 3 and response[scapy.ICMP].code in [1, 2, 3, 9, 10, 13]:
            return "filtered"
    return None
# Example
# result = ack_scan("192.168.1.1", 80)
# print(f"Port 80 is {result}")
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

3.6. Common Network Ports for Scanning: This is a knowledge-based item. Common ports include:

21 (FTP)

22 (SSH)

23 (Telnet)

25 (SMTP)

53 (DNS)

80 (HTTP)

110 (POP3)

139 (NetBIOS)

143 (IMAP)

443 (HTTPS)

445 (SMB)

3306 (MySQL)

3389 (RDP)

5432 (PostgreSQL)

8080 (HTTP Alternate)

You can create a default list of common ports to scan.

3.7. Implementing TCP SYN Stealth Scanning: This is already covered by the is_port_open function, as it uses SYN packets and sends a RST to close the connection gracefully. This is considered "stealthy" because it doesn't complete the full TCP handshake.

3.8. Concurrent Port Scanning Implementation: Use the same approach as in section 2.7 (ARP/ICMP scanning), but apply it to the port scanning functions:

def parallel_port_scan(ip_address, ports, max_workers=20):
     open_ports = []
     with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
         future_to_port = {executor.submit(is_port_open, ip_address, port): port for port in ports} #is_port_open function used
         for future in concurrent.futures.as_completed(future_to_port):
             if future.result():
                 open_ports.append(future_to_port[future])
     return open_ports
 #Example
 # open_ports = parallel_port_scan("192.168.1.1", range(1, 1025))
 # print(f"Open ports: {open_ports}")
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

4. Results Processing

This section focuses on handling, parsing, displaying, and exporting the scan results.

4.1. Network Scanner Results Implementation:

Description: Design a data structure to store the scan results. A list of dictionaries is a good choice.

Example:

# Example scan results
results = [
    {"ip": "192.168.1.1", "mac": "00:11:22:33:44:55", "status": "up", "open_ports": [22, 80, 443]},
    {"ip": "192.168.1.2", "mac": "AA:BB:CC:DD:EE:FF", "status": "up", "open_ports": [80]},
    {"ip": "192.168.1.3", "mac": None, "status": "down", "open_ports": []},
]
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

Integration: Combine the results from the ARP/ICMP scans and the port scans into this data structure.

4.2. Network Scanning Data Parser: The parsing is mostly done within the scan functions themselves (e.g., extracting IP/MAC from ARP responses, checking flags in TCP responses). This section might involve additional processing, such as resolving hostnames (using socket.gethostbyaddr(), but be aware of potential reverse DNS lookup issues) or looking up service names for known ports.

4.3. Implementing a Command-Line Interface for Network Scanner Results:

Description: Create a command-line interface (CLI) to allow users to run scans and view results. Use libraries like argparse (built-in) or click (third-party) for a user-friendly CLI.

Example (using argparse):

import argparse
# ... (your scanning functions from previous sections) ...

def main():
    parser = argparse.ArgumentParser(description="Network Scanner Pro")
    parser.add_argument("ip_range", help="The IP range to scan (e.g., 192.168.1.0/24)")
    parser.add_argument("-p", "--ports", help="Comma-separated port ranges (e.g., 22,80,1-1024)", default="1-1024")
    parser.add_argument("-t", "--threads", help="Number of threads for parallel scanning", type=int, default=10)
    args = parser.parse_args()

    scan_results = parallel_scan(args.ip_range, max_workers=args.threads) # parallel_scan function from section 2.7

    for result in scan_results:
        if result['status'] == 'up':
           print(f"Host: {result['ip']} ({result.get('mac', 'N/A')}) is UP")
           open_ports = parallel_port_scan(result["ip"], args.ports.split(","), max_workers = args.threads)
           if open_ports:
               print(f"  Open Ports: {', '.join(map(str, open_ports))}")

if __name__ == "__main__":
    main()
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

Usage: python your_script.py 192.168.1.0/24 -p 22,80,443 -t 20

4.4. Adding Export Functionality to Network Scanner:

Description: Allow users to export scan results to different formats (e.g., CSV, JSON, TXT).

Example (CSV export):

import csv

def export_to_csv(results, filename):
    """Exports scan results to a CSV file.

    Args:
        results: The scan results (list of dictionaries).
        filename: The name of the CSV file to create.
    """
    with open(filename, 'w', newline='') as csvfile:
        fieldnames = ['ip', 'mac', 'status', 'open_ports']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

        writer.writeheader()
        for result in results:
            result['open_ports'] = ','.join(map(str,result.get('open_ports',[]))) #convert port list to string
            writer.writerow(result)

  #Add this functionality to the argParse
  parser.add_argument("-o", "--output", help="Output file name (CSV format)", default=None)

  #In main() after scanning
  if args.output:
      export_to_csv(scan_results, args.output)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

4.5. Network Scanner GUI Implementation:

Description: Create a graphical user interface (GUI) for easier interaction and visualization. Popular libraries include tkinter (built-in), PyQt, Kivy, or wxPython. This is a larger task and requires a separate design and implementation effort.

Key Considerations:

Input Fields: For IP range, port ranges, scan options.

Table/List View: To display scan results in a tabular format.

Graph Visualization: Integrate networkx and matplotlib (or similar) to display a network graph.

Progress Bar: Show scan progress.

Start/Stop Buttons: Control scan execution.

Export Options: Provide buttons to export results.

4.6. Implementing Data Visualization for Network Topology and Open Ports:

See 1.4 for library installation

Example Network Graph (using networkx and matplotlib):
```python
import networkx as nx
import matplotlib.pyplot as plt

def visualize_network(results):
    """Visualizes the network topology using networkx and matplotlib."""

    graph = nx.Graph()
    for result in results:
        if result['status'] == 'up':
            graph.add_node(result['ip'], mac=result.get('mac', 'N/A'))
            for port in result.get('open_ports', []):
                graph.add_edge(result['ip'], f"{result['ip']}:{port}")

    pos = nx.spring_layout(graph)  # Layout algorithm for node positioning
    nx.draw(graph, pos, with_labels=True, node_size=500, node_color="skyblue")

     #Draw edge labels (ports)
    edge_labels = {(u, v): v.split(':')[-1] for u, v in graph.edges if ':' in v}
    nx.draw_networkx_edge_labels(graph, pos, edge_labels=edge_labels)

    plt.title("Network Topology")
    plt.show()
 # Example Usage
 # visualize_network(results)

```
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

4.7. Enhancing Network Scanner with Sorting and Filtering:

Description: Add functionality to sort and filter scan results based on different criteria (IP address, MAC address, open ports, status).

Implementation (CLI example - sorting):

# Add an argument to the argparse parser:
parser.add_argument("-s", "--sort", help="Sort results by (ip, mac, ports)", default=None)
# Inside main() after scanning
if args.sort:
    if args.sort == "ip":
        scan_results.sort(key=lambda x: ipaddress.ip_address(x['ip']))
    elif args.sort == 'mac':
        scan_results.sort(key = lambda x: x.get('mac', ''))
    elif args.sort == "ports":
        scan_results.sort(key=lambda x: len(x.get('open_ports', [])), reverse = True) #Sorts by the number of open ports.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

Implementation (Filtering, using list comprehensions in CLI):

def filter_results(results, filter_criteria):
     filtered_list = []
     #Filtering based on open port
     if 'port' in filter_criteria:
         port_to_filter = int(filter_criteria.split("=")[1])
         filtered_list = [r for r in results if port_to_filter in r.get('open_ports', [])]

     #Filtering based on Status
     elif 'status' in filter_criteria:
          status_to_filter = filter_criteria.split("=")[1]
          filtered_list = [r for r in results if r['status'] == status_to_filter]

     #Extend for mac and ip
     return filtered_list
#In argParse
parser.add_argument("-f", "--filter", help="Filter results (e.g., port=80, status=up)", default=None)

#In main()
 if args.filter:
    scan_results = filter_results(scan_results, args.filter)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

4.8. Implementing Save and Load Scanning Sessions:

Description: Allow users to save their scan settings and results to a file and load them later. JSON is a good format for this.

Example (using JSON):
```python
import json
def save_session(results, settings, filename):
"""Saves the scan results and settings to a JSON file."""
session_data = {"results": results, "settings": settings}
with open(filename, 'w') as f:
json.dump(session_data, f, indent=4)
def load_session(filename):
"""Loads scan results and settings from a JSON file."""
with open(filename, 'r') as f:
session_data = json.load(f)
return session_data['results'], session_data['settings']

#Argparse integration
parser.add_argument("--save", help="Save session to a file", default=None)
parser.add_argument("--load", help="Load session from a file", default=None)
#Main
if args.save:
    settings = {'ip_range': args.ip_range, 'ports': args.ports, 'threads': args.threads}
    save_session(scan_results, settings, args.save)
if args.load:
   scan_results, settings = load_session(args.load)
   #You might want to update the argparse args with loaded setting
   #args.ip_range = settings['ip_range'] ....
```
